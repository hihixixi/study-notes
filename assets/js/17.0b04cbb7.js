(window.webpackJsonp=window.webpackJsonp||[]).push([[17],{615:function(v,t,a){"use strict";a.r(t);var _=a(52),s=Object(_.a)({},(function(){var v=this,t=v.$createElement,a=v._self._c||t;return a("ContentSlotsDistributor",{attrs:{"slot-key":v.$parent.slotKey}},[a("h2",{attrs:{id:"类"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#类"}},[v._v("#")]),v._v(" 类")]),v._v(" "),a("h3",{attrs:{id:"声明类"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#声明类"}},[v._v("#")]),v._v(" 声明类")]),v._v(" "),a("ul",[a("li",[v._v("类名每个单词首字母大写")]),v._v(" "),a("li",[v._v("类只能继承一个父类(超类)")]),v._v(" "),a("li",[v._v("类可以实现多个接口，接口与接口之间以逗号隔开")])]),v._v(" "),a("h3",{attrs:{id:"声明成员变量"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#声明成员变量"}},[v._v("#")]),v._v(" 声明成员变量")]),v._v(" "),a("ul",[a("li",[v._v("类中的成员变量称为字段")]),v._v(" "),a("li",[v._v("方法或代码块中的变量称为局部变量")]),v._v(" "),a("li",[v._v("方法声明中的变量称为参数")])]),v._v(" "),a("h3",{attrs:{id:"定义方法"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#定义方法"}},[v._v("#")]),v._v(" 定义方法")]),v._v(" "),a("ul",[a("li",[v._v("官方推荐方法名第一个单词应该为动词")])]),v._v(" "),a("h4",{attrs:{id:"重载方法"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#重载方法"}},[v._v("#")]),v._v(" 重载方法")]),v._v(" "),a("ul",[a("li",[v._v("方法重载，需要方法具有不同的方法签名")]),v._v(" "),a("li",[v._v("方法签名包括方法名和方法参数")]),v._v(" "),a("li",[v._v("方法参数的个数、类型、顺序都会导致方法的签名不同")]),v._v(" "),a("li",[v._v("方法的不同返回值不会发生方法重载")])]),v._v(" "),a("h3",{attrs:{id:"类的构造函数"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#类的构造函数"}},[v._v("#")]),v._v(" 类的构造函数")]),v._v(" "),a("ul",[a("li",[v._v("构造函数是类用于创建对象并初始化一些数据的一个特殊方法")]),v._v(" "),a("li",[v._v("构造函数与方法的不同是，构造方法的名称是类名，构造函数没有返回值类型，构造函数也可以重载")]),v._v(" "),a("li",[v._v("如果你没有现实的提供构造函数，编译器会自动添加一个无参的构造函数，此构造函数会调用超类的构造函数，如果超类没有构造函数，编译器会报错")]),v._v(" "),a("li",[v._v("如果一个类有构造函数，但是不能显示的调用，说明该类不可以通过 new 的方式创建对象")])]),v._v(" "),a("h2",{attrs:{id:"对象"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#对象"}},[v._v("#")]),v._v(" 对象")]),v._v(" "),a("h3",{attrs:{id:"返回值类型"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#返回值类型"}},[v._v("#")]),v._v(" 返回值类型")]),v._v(" "),a("p",[v._v("如果方法返回的是引用数据类型，我们可以直接返回对应的返回类型，也可以返回其子类，返回子类被称作协变返回类型的技术")]),v._v(" "),a("h3",{attrs:{id:"this关键字"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#this关键字"}},[v._v("#")]),v._v(" this关键字")]),v._v(" "),a("ul",[a("li",[v._v("类中的方法都隐藏了this参数")]),v._v(" "),a("li",[v._v("在构造函数中，您还可以使用"),a("code",[v._v("this")]),v._v("关键字调用同一类中的另一个构造函数。这样做称为"),a("em",[v._v("显式构造函数调用")])]),v._v(" "),a("li",[v._v("如果显示调用构造函数，显示调用这以语句必须写在第一行")])]),v._v(" "),a("h3",{attrs:{id:"类修饰符"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#类修饰符"}},[v._v("#")]),v._v(" 类修饰符")]),v._v(" "),a("ul",[a("li",[v._v("通常我们会使用public修饰类，这表明该类对任意地方都可见，如果没有写任何修饰符则表明该类只在本包可见，外部类不可以使用private和protected进行修饰")]),v._v(" "),a("li",[v._v("对成员进行修饰，可以使用public、protected、default(表示不写修饰符)、private")]),v._v(" "),a("li",[v._v("public：表明该成员，在任何地方都可见")]),v._v(" "),a("li",[v._v("protected:表明该成员在本包，子类都可见")]),v._v(" "),a("li",[v._v("default：表明该成员在本包可见，子类(前提是该子类不在本包)不可见")]),v._v(" "),a("li",[v._v("private:成员只在本类可见")]),v._v(" "),a("li",[v._v("对字段进行修饰时，尽量使用private修饰，除非你有特殊需求才使用其他修饰符")])]),v._v(" "),a("h3",{attrs:{id:"static关键字"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#static关键字"}},[v._v("#")]),v._v(" static关键字")]),v._v(" "),a("ul",[a("li",[v._v("static修饰的成员是属于类，不属于类的实例，每个实例共享类成员")]),v._v(" "),a("li",[v._v("实例方法可以访问static成员和非static成员，类方法只能访问static成员，且类方法没有this关键字")]),v._v(" "),a("li",[v._v("对象引用也可以使用static修饰的成员，但不推荐这样使用")])]),v._v(" "),a("h2",{attrs:{id:"嵌套类"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#嵌套类"}},[v._v("#")]),v._v(" 嵌套类")]),v._v(" "),a("ul",[a("li",[v._v("嵌套类分为两类：非静态和静态。非静态嵌套类也可以称为"),a("em",[v._v("内部类")]),v._v("，"),a("em",[v._v("static")]),v._v("声明的嵌套类称为"),a("em",[v._v("静态嵌套类")])]),v._v(" "),a("li",[v._v("非静态嵌套类，可以直接访问外部类的所有成员，无论私有或者静态成员，静态内部类只能访问外部类的静态成员，前提是不创建嵌套类的对象的情况下")]),v._v(" "),a("li",[v._v("当一个类只会被另一个类使用时，我们可以考虑将该类封装成一个内部类")]),v._v(" "),a("li",[v._v("非静态内部类创建实例需要外部类的实例，静态内部类创建实例与外部类创建实例方式相同")])]),v._v(" "),a("h3",{attrs:{id:"本地类"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#本地类"}},[v._v("#")]),v._v(" 本地类")]),v._v(" "),a("ul",[a("li",[v._v("本地类，是定义在"),a("code",[v._v("块")]),v._v("中的类是非静态的，在java 8之后本地类可以访问块中非final的变量")]),v._v(" "),a("li",[v._v("不可以在块内声明接口，接口本质上是静态的，不可以在本地类中写静态方法或接口")]),v._v(" "),a("li",[v._v("本地类可以拥有static成员，但是前提是要final修饰")])]),v._v(" "),a("h3",{attrs:{id:"匿名类"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#匿名类"}},[v._v("#")]),v._v(" 匿名类")]),v._v(" "),a("ul",[a("li",[v._v("匿名类是一个表达式，所以它是语句的一部分，这也是匿名类后面有分号的原因")]),v._v(" "),a("li",[v._v("匿名类不能声明构造器，因为它没有名字，匿名类在静态成员方面的限制与本地类相同")]),v._v(" "),a("li",[v._v("匿名类也可以访问外部的变量")]),v._v(" "),a("li",[v._v("如果接口只有一个抽象方法(不包括静态方法和默认方法)，可以使用**lambda*表达式代替匿名类")])]),v._v(" "),a("h3",{attrs:{id:"lambda表达式"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#lambda表达式"}},[v._v("#")]),v._v(" lambda表达式")]),v._v(" "),a("ul",[a("li",[v._v("只有一个抽象方法的接口称为函数式接口，"),a("code",[v._v("java.util.function")]),v._v("包下可以查看函数式接口,更多信息直接查阅官网")])]),v._v(" "),a("h4",{attrs:{id:"方法引用"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#方法引用"}},[v._v("#")]),v._v(" 方法引用")]),v._v(" "),a("ul",[a("li",[a("p",[v._v("方法引用可以看作是lambda的升级版")])]),v._v(" "),a("li",[a("p",[v._v("方法引用有四种情况:")]),v._v(" "),a("p",[v._v("引用类的静态方法: Class::staticMethodName")]),v._v(" "),a("p",[v._v("引用具体实例的实例方法: Object::methodName")]),v._v(" "),a("p",[v._v("引用特定类型的实例方法: String::concat")]),v._v(" "),a("p",[v._v("引用构造函数:ClassName::new")])])]),v._v(" "),a("h2",{attrs:{id:"枚举类"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#枚举类"}},[v._v("#")]),v._v(" 枚举类")]),v._v(" "),a("ul",[a("li",[v._v("枚举类是一种特殊的数据类型，它使变量能够成为一组预定义的常量")]),v._v(" "),a("li",[v._v("java种所有的枚举类都继承了 Enum 类，所以不能再扩展其它类了")]),v._v(" "),a("li",[v._v("枚举类默认添加了一些方法")]),v._v(" "),a("li",[v._v("枚举类的构造函数必须是包私有(不写修饰符)或者是私有的，因为它会自己调用并初始化你定义的常量")])])])}),[],!1,null,null,null);t.default=s.exports}}]);