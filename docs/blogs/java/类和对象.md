[TOC]

## 类

### 声明类

- 类名每个单词首字母大写
- 类只能继承一个父类(超类)
- 类可以实现多个接口，接口与接口之间以逗号隔开

### 声明成员变量

- 类中的成员变量称为字段
- 方法或代码块中的变量称为局部变量
- 方法声明中的变量称为参数

### 定义方法

- 官方推荐方法名第一个单词应该为动词

#### 重载方法

- 方法重载，需要方法具有不同的方法签名
- 方法签名包括方法名和方法参数
- 方法参数的个数、类型、顺序都会导致方法的签名不同
- 方法的不同返回值不会发生方法重载

### 类的构造函数

- 构造函数是类用于创建对象并初始化一些数据的一个特殊方法
- 构造函数与方法的不同是，构造方法的名称是类名，构造函数没有返回值类型，构造函数也可以重载
- 如果你没有现实的提供构造函数，编译器会自动添加一个无参的构造函数，此构造函数会调用超类的构造函数，如果超类没有构造函数，编译器会报错
- 如果一个类有构造函数，但是不能显示的调用，说明该类不可以通过 new 的方式创建对象

## 对象

### 返回值类型

如果方法返回的是引用数据类型，我们可以直接返回对应的返回类型，也可以返回其子类，返回子类被称作协变返回类型的技术

### this关键字

- 类中的方法都隐藏了this参数
- 在构造函数中，您还可以使用`this`关键字调用同一类中的另一个构造函数。这样做称为*显式构造函数调用*
- 如果显示调用构造函数，显示调用这以语句必须写在第一行

### 类修饰符

- 通常我们会使用public修饰类，这表明该类对任意地方都可见，如果没有写任何修饰符则表明该类只在本包可见，外部类不可以使用private和protected进行修饰
- 对成员进行修饰，可以使用public、protected、default(表示不写修饰符)、private
- public：表明该成员，在任何地方都可见
- protected:表明该成员在本包，子类都可见
- default：表明该成员在本包可见，子类(前提是该子类不在本包)不可见
- private:成员只在本类可见
- 对字段进行修饰时，尽量使用private修饰，除非你有特殊需求才使用其他修饰符

### static关键字

- static修饰的成员是属于类，不属于类的实例，每个实例共享类成员
- 实例方法可以访问static成员和非static成员，类方法只能访问static成员，且类方法没有this关键字
- 对象引用也可以使用static修饰的成员，但不推荐这样使用

## 嵌套类

- 嵌套类分为两类：非静态和静态。非静态嵌套类也可以称为*内部类*，*static*声明的嵌套类称为*静态嵌套类*
- 非静态嵌套类，可以直接访问外部类的所有成员，无论私有或者静态成员，静态内部类只能访问外部类的静态成员，前提是不创建嵌套类的对象的情况下
- 当一个类只会被另一个类使用时，我们可以考虑将该类封装成一个内部类
- 非静态内部类创建实例需要外部类的实例，静态内部类创建实例与外部类创建实例方式相同

### 本地类

- 本地类，是定义在`块`中的类是非静态的，在java 8之后本地类可以访问块中非final的变量
- 不可以在块内声明接口，接口本质上是静态的，不可以在本地类中写静态方法或接口
- 本地类可以拥有static成员，但是前提是要final修饰

### 匿名类

- 匿名类是一个表达式，所以它是语句的一部分，这也是匿名类后面有分号的原因
- 匿名类不能声明构造器，因为它没有名字，匿名类在静态成员方面的限制与本地类相同
- 匿名类也可以访问外部的变量
- 如果接口只有一个抽象方法(不包括静态方法和默认方法)，可以使用**lambda*表达式代替匿名类

### lambda表达式

- 只有一个抽象方法的接口称为函数式接口，`java.util.function`包下可以查看函数式接口,更多信息直接查阅官网

#### 方法引用

- 方法引用可以看作是lambda的升级版

- 方法引用有四种情况:

  引用类的静态方法: Class::staticMethodName

  引用具体实例的实例方法: Object::methodName

  引用特定类型的实例方法: String::concat

  引用构造函数:ClassName::new

## 枚举类

- 枚举类是一种特殊的数据类型，它使变量能够成为一组预定义的常量
- java种所有的枚举类都继承了 Enum 类，所以不能再扩展其它类了
- 枚举类默认添加了一些方法
- 枚举类的构造函数必须是包私有(不写修饰符)或者是私有的，因为它会自己调用并初始化你定义的常量