[TOC]

## 接口

接口是一种引用数据类型，接口不能被实例化

### 定义接口

- 接口只能由public或default(即不写修饰符)进行修饰
- public修饰，表示该接口任意包均可见
- default修饰，表示只有本包可见
- 接口可以多继承
- 接口内由抽象方法，默认方法，静态方法，所有类型的方法默认都是public修饰(不可以用其他区修饰符)，所以可以省略public
- 接口内可以声明常量，默认由public,static,final进行修饰，所以也可以不写

### 实现接口

- 一个类可以实现多个接口，接口与接口之间使用逗号隔开
- 默认方法，需要实例化才能调用，且需要写方法体，默认方法种可以调用接口中的静态方法
- 静态方法只能是接口才能调用，子类实例化对象不可以调用
- 以上两种方法，均不强制子类实现，所以也是扩展接口的一种方式

## 继承

- 从一个类派生出的类被称做子类、派生类、扩展类，被派生类被称作父类、超类、基类
- 所有类都间接或直接派生自Object类
- 子类继承了父类的所有字段、方法、嵌套类，但是没有继承构造方法(因为不属于类的成员)，但是子类可以调用父类的构造方法
- 父类private修饰的字段方法，子类不可以直接调用，只能间接
- 父类default(即不写修饰符)修饰的字段方法，本包子类可以直接调用，其他包子类不可以
- 父类使用protected修饰的字段方法，本包其他包都可以直接调用

### 覆盖和隐藏方法

- 覆盖父类方法，需要子类方法签名与返回类型都与父类一致，java允许子类覆盖父类方法时方法的返回类型是父类方法的返回类型的子类，这种情况专业术语称作协变返回

#### 接口方法

- 当接口与父类由相同方法签名的方法时，子类调用时优先调用父类的继承过来的方法
- 当接口都由相同方法签名的方法时，子接口重写了父接口的方法时，实现类调用时会调用子接口的重写方法
- 如果两个基础接口没有任何的继承关系但是它们有相同的方法签名的默认方法，一个类实现类它们则子类必须重写该方法且调用默认方法时必须显示指明，interfaceName.super.methodName
- 接口的静态方法，不会被继承
- 子类的方法修饰符或返回值类型，只能比父类的修饰符限制级别高或相同不能低

### 多态性

多态是一个重要的特性之一，在处于多态的情况下变量调用重写的方法时并不是根据变量的类型调用方法，而是根据变量引用的的对象调用方法，这种行为被称为虚拟方法调用

### super关键字

- 如果子类有与父类相同名称的字段，子类的字段会覆盖父类的字段即使子父类对应字段的名字不相同
- 如果子父类之间发生字段或方法覆盖时，需要使用super关键字进行调用被覆盖的字段或方法
- 如果我们显示的调用父类的构造函数，那么该语句必须写在子类构造函数的第一条，否则会报错
- 如果我们没有显示的调用父类的构造函数，编译器会自动帮我们调用父类的无参构造函数，如果父类没有无参构造函数，那么会报错

### final关键字

构造函数内的调用的函数通常被声明为final，防止子类对其进行覆盖

### 抽象方法和类

- abstract修饰的类被称为抽象类，抽象类不能被实例化
- abstract修饰的方法被称为抽象方法
- 子类必须实现抽象类中的抽象方法

#### 抽象类与接口的区别

- 抽象类可以正常的定义字段和使用修饰符
- 抽象类如果实现了接口可以不提供接口的方法实现，而是由继承了抽象类的子类进行方法实现
- 接口不可以继承类